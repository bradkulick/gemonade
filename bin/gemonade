#!/bin/bash

# Gemonade: The Gemini CLI Persona Wrapper
# Version: 4.2.4 (The Polished Notifier Update)

# 1. Configuration & Paths
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do 
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" 
done
GEMONADE_HOME="$( cd -P "$( dirname "$SOURCE" )/.." >/dev/null 2>&1 && pwd )"

CONFIG_FILE="$HOME/.gemonade_config"
STATE_DIR="$HOME/.gemonade"
LAST_CLEAN_FILE="$STATE_DIR/last_clean"
G_CORE_VENV="$STATE_DIR/.venv"

# Default Paths (Can be overridden in CONFIG_FILE)
G_KNOWLEDGE_DIR="$GEMONADE_HOME/knowledge"
G_PACKAGE_ROOT="$GEMONADE_HOME/packages"
G_CORE_PERSONA="$GEMONADE_HOME/core/CORE_PERSONA.md"
G_SAVER_SCRIPT="$GEMONADE_HOME/tools/save_session.py"
G_INSTALLED_DIR="$G_PACKAGE_ROOT/installed"

# Load user config if it exists
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# 2. Project Context Detection (V4)
detect_project_context() {
    # Hierarchy: Flag (passed as arg) > Env Var > Git Root > Config File > Default
    local explicit_flag=$1
    
    if [ -n "$explicit_flag" ]; then
        echo "$explicit_flag"
        return
    fi

    if [ -n "$GEMONADE_PROJECT" ]; then
        echo "$GEMONADE_PROJECT"
        return
    fi

    # Try Git Root Name
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        local git_root=$(git rev-parse --show-toplevel)
        basename "$git_root"
        return
    fi
    
    # Try Local Config
    if [ -f ".gemonade_project" ]; then
        head -n 1 ".gemonade_project"
        return
    fi

    echo "global"
}

# 3. JIT Hooks (V4)
get_python_cmd() {
    # Prefer Core Venv, fallback to system
    if [ -f "$G_CORE_VENV/bin/python3" ]; then
        echo "$G_CORE_VENV/bin/python3"
    else
        echo "python3"
    fi
}

run_hook() {
    local hook_name=$1
    local context=$2
    local persona=$3
    local py_cmd=$(get_python_cmd)
    
    # Example: Update Check on Init
    if [[ "$hook_name" == "on_init" ]]; then
        # Check for framework updates casually (async)
        (
            cd "$GEMONADE_HOME"
            if git remote update >/dev/null 2>&1; then
                local local_hash=$(git rev-parse @ 2>/dev/null)
                local remote_hash=$(git rev-parse @{u} 2>/dev/null)
                if [ -n "$local_hash" ] && [ -n "$remote_hash" ]; then
                    if [ "$local_hash" != "$remote_hash" ]; then
                        touch "$STATE_DIR/update_available"
                    else
                        rm -f "$STATE_DIR/update_available"
                    fi
                fi
            fi
        ) &    fi

    # Example: Ingest Memory on Exit
    if [[ "$hook_name" == "on_exit" ]]; then
        if [ -f "$GEMONADE_HOME/tools/ingest_memory.py" ]; then
            # We use the Core Venv python here
            "$py_cmd" "$GEMONADE_HOME/tools/ingest_memory.py" --project "$context" --persona "$persona" >/dev/null 2>&1
        fi
    fi
}

# 4. Lazy Background Cleanup
mkdir -p "$STATE_DIR"
current_time=$(date +%s)
last_clean_time=0
if [ -f "$LAST_CLEAN_FILE" ]; then
    last_clean_time=$(cat "$LAST_CLEAN_FILE" 2>/dev/null)
fi

if [ $((current_time - last_clean_time)) -gt 86400 ]; then
    if [ -f "$GEMONADE_HOME/tools/cleanup_sessions.sh" ]; then
        bash "$GEMONADE_HOME/tools/cleanup_sessions.sh" > /dev/null 2>&1 &
        echo $current_time > "$LAST_CLEAN_FILE"
    fi
fi

# 5. Helpers
usage() {
    echo "Usage: gemonade [command] [gem] [--project=<name>]"
    echo ""
    echo "Commands:"
    echo "  run <gem>               Start a session (default command)"
    echo "  list                    List available Gems"
    echo "  install <url|path>      Install a Gem from Git or Local Path"
    echo "  uninstall <gem>         Remove an installed Gem"
    echo "  update <gem>            Update an installed Gem"
    echo "  advanced-memory <cmd>   Manage Intelligence Pack (enable/disable)"
    echo "  search <term>           Search for Gems on GitHub"
    echo "  config                  Show current configuration"
    echo "  help                    Show this help message"
    echo ""
    echo "Flags:"
    echo "  --project=<name>        Explicitly set the project context tag."
    echo "  --scope=<mode>          Set visibility scope: project (default), persona, or global."
    echo ""
    echo "üí° Pro Tip: To create new Gems or understand how this framework works,"
    echo "            run 'gemonade sys' to chat with the Gemonade Expert."
    exit 1
}

find_persona_file() {
    local name=$1
    # Core Protection: sys and general always come from core
    if [[ "$name" == "sys" || "$name" == "general" ]]; then
        echo "$G_PACKAGE_ROOT/core/$name/persona.md"
        return
    fi
    # Priority: Local > Installed > Core
    if [ -f "$G_PACKAGE_ROOT/local/$name/persona.md" ]; then
        echo "$G_PACKAGE_ROOT/local/$name/persona.md"
    elif [ -f "$G_INSTALLED_DIR/$name/persona.md" ]; then
        echo "$G_INSTALLED_DIR/$name/persona.md"
    elif [ -f "$G_PACKAGE_ROOT/core/$name/persona.md" ]; then
        echo "$G_PACKAGE_ROOT/core/$name/persona.md"
    fi
}

get_json_value() {
    local file=$1
    local key=$2
    if [ -f "$file" ]; then
        # Robust Python parsing instead of fragile sed/grep
        python3 -c "import json, sys; data=json.load(open('$file')); print(data.get('$key', ''))" 2>/dev/null
    fi
}

# 6. Command: Install
install_gem() {
    local source=$1
    if [ -z "$source" ]; then
        echo "‚ùå Usage: gemonade install <git-url> | <local-path> | <user/repo>"
        exit 1
    fi

    local install_path=""
    local temp_name=""

    # --- Phase 1: Fetching ---
    if [ -d "$source" ]; then
        # Case A: Local Directory
        local abs_source=$(cd "$source" && pwd)
        temp_name=$(basename "$abs_source")
        install_path="$G_INSTALLED_DIR/$temp_name"
        
        echo "üì¶ Installing from local path: $abs_source"
        
        if [ ! -f "$abs_source/gem.json" ]; then
             echo "‚ùå Error: '$abs_source' does not contain a gem.json manifest."
             exit 1
        fi

        if [ -d "$install_path" ]; then
            echo "‚ö†Ô∏è  Gem '$temp_name' already exists."
            read -p "Overwrite? [y/N] " -n 1 -r
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then exit 1; fi
            rm -rf "$install_path"
        fi
        
        mkdir -p "$G_INSTALLED_DIR"
        cp -r "$abs_source" "$install_path"
        rm -rf "$install_path/.git" "$install_path/.venv" "$install_path/__pycache__"

    else
        # Case B: Git URL / GitHub Shorthand
        local repo_url="$source"
        if [[ "$repo_url" != http* && "$repo_url" != git@* ]]; then
            repo_url="https://github.com/$repo_url.git"
        fi

        temp_name=$(basename "$repo_url" .git)
        install_path="$G_INSTALLED_DIR/$temp_name"

        if [ -d "$install_path" ]; then
            echo "‚ö†Ô∏è  Gem directory '$temp_name' already exists."
            read -p "Reinstall? [y/N] " -n 1 -r
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then exit 1; fi
            rm -rf "$install_path"
        fi

        echo "üì¶ Cloning $repo_url..."
        mkdir -p "$G_INSTALLED_DIR"
        git clone "$repo_url" "$install_path" || { echo "‚ùå Clone failed"; exit 1; }
    fi

    # --- Phase 2: Configuration ---
    local manifest_name=$(get_json_value "$install_path/gem.json" "name")
    if [ -n "$manifest_name" ] && [ "$manifest_name" != "$temp_name" ]; then
        if [ -d "$G_INSTALLED_DIR/$manifest_name" ]; then
            echo "‚ö†Ô∏è  A Gem named '$manifest_name' is already installed. Keeping folder '$temp_name'."
        else
            echo "üè∑Ô∏è  Renaming '$temp_name' to '$manifest_name' (per gem.json)..."
            mv "$install_path" "$G_INSTALLED_DIR/$manifest_name"
            install_path="$G_INSTALLED_DIR/$manifest_name"
            temp_name=$manifest_name
        fi
    fi

    echo "‚öôÔ∏è  Configuring '$temp_name'...
    hydrate_gem "$install_path"

    echo "‚úÖ Successfully installed '$temp_name'."
}

# 7. Command: Uninstall
uninstall_gem() {
    local name=$1
    local path="$G_INSTALLED_DIR/$name"

    if [ -z "$name" ]; then echo "‚ùå Usage: gemonade uninstall <name>"; exit 1; fi
    if [[ "$name" == "sys" || "$name" == "general" ]]; then echo "‚ùå Cannot uninstall Core gems."; exit 1; fi
    if [ ! -d "$path" ]; then echo "‚ùå Gem '$name' not found in Installed packages."; exit 1; fi

    echo "üóëÔ∏è  Uninstalling '$name'...
    rm -rf "$path"
    echo "‚úÖ Removed package files. (Session logs preserved)."
}

# 8. Command: Hydrate (Setup Venv)
hydrate_gem() {
    local path=$1
    local gem_json="$path/gem.json"
    
    local req_file=""
    if [ -f "$gem_json" ]; then
        local json_req=$(get_json_value "$gem_json" "python_dependencies")
        if [ -n "$json_req" ]; then req_file="$path/$json_req"; fi
    fi
    
    if [ -z "$req_file" ] && [ -f "$path/requirements.txt" ]; then
        req_file="$path/requirements.txt"
    fi

    if [ -n "$req_file" ] && [ -f "$req_file" ]; then
        echo "üêç Python dependencies detected. Creating isolated environment..."
        python3 -m venv "$path/.venv"
        "$path/.venv/bin/pip" install -r "$req_file"
        echo "‚úÖ Virtual environment created."
    fi
}

# 9. Advanced Memory Management
manage_advanced_memory() {
    local action=$1
    mkdir -p "$(dirname "$G_CORE_VENV")"
    
    if [ ! -d "$G_CORE_VENV" ]; then
        echo "üêç Creating Core Venv..."
        python3 -m venv "$G_CORE_VENV"
    fi

    if [[ "$action" == "enable" ]]; then
        echo "üß† Enabling Advanced Memory..."
        
        # Step 1: Force CPU-only PyTorch to save ~1.5GB of disk space
        echo "   üì¶ Installing lightweight CPU-only AI engine..."
        if ! "$G_CORE_VENV/bin/pip" install torch --index-url https://download.pytorch.org/whl/cpu; then
            echo "   ‚ö†Ô∏è  Warning: CPU-only pre-install failed. Attempting standard install..."
        fi

        echo "   üì¶ Installing ChromaDB and recall tools..."
        if "$G_CORE_VENV/bin/pip" install -r "$GEMONADE_HOME/tools/requirements.txt"; then
            echo "   ‚úÖ Advanced Memory Enabled."
        else
            echo "   ‚ùå Installation failed. Please check your disk space or connection."
            return 1
        fi
        
    elif [[ "$action" == "disable" ]]; then
        echo "üß† Disabling Advanced Memory..."
        
        # 1. Clean up Storage
        local db_path="$STATE_DIR/chroma_db"
        if [ -d "$db_path" ]; then
            echo "   üóëÔ∏è  Removing Vector Database ($db_path)..."
            rm -rf "$db_path"
        else
            echo "   ‚ö™ No Vector Database found."
        fi

        # 2. Clean up Libraries
        echo "   üßπ Uninstalling heavy dependencies..."
        "$G_CORE_VENV/bin/pip" uninstall -y chromadb sentence-transformers >/dev/null 2>&1
        
        echo "   ‚úÖ Advanced Memory Disabled (Space Reclaimed)."
    else
        echo "Usage: gemonade advanced-memory [enable|disable]"
    fi
}

# 10. Command: List Personas
list_personas() {
    echo "Available Gemonade Gems:"
    
    local names
    names=$(ls -d "$G_PACKAGE_ROOT/core/"* 2>/dev/null | xargs -n 1 basename 2>/dev/null)
    names+=" "$(ls -d "$G_INSTALLED_DIR/"* 2>/dev/null | xargs -n 1 basename 2>/dev/null)
    names+=" "$(ls -d "$G_PACKAGE_ROOT/local/"* 2>/dev/null | xargs -n 1 basename 2>/dev/null)
    unique_names=$(echo "$names" | tr ' ' '\n' | sort -u)

    local list_local=""
    local list_installed=""
    local list_core=""

    for name in $unique_names; do
        [ -z "$name" ] && continue
        persona_file=$(find_persona_file "$name")
        
        if [ -f "$persona_file" ]; then
            desc=$(grep -m 1 "Objective:" "$persona_file" | sed -E 's/.*Objective:[ *]*//' | sed 's/[ *]*$//')
            [ -z "$desc" ] && desc="No objective defined."
            
            line=$(printf "  - %-15s : %s" "$name" "$desc")
            
            if [[ "$persona_file" == *"/packages/local/"* ]]; then
                list_local="${list_local}${line}"$'\n'
            elif [[ "$persona_file" == *"/packages/installed/"* ]]; then
                list_installed="${list_installed}${line}"$'\n'
            elif [[ "$persona_file" == *"/packages/core/"* ]]; then
                list_core="${list_core}${line}"$'\n'
            fi
        fi
    done

    echo ""
    echo "LOCAL (Private & Custom)"
    [ -n "$list_local" ] && echo -n "$list_local" || echo "  (none)"

    echo ""
    echo "INSTALLED (Community Gems)"
    [ -n "$list_installed" ] && echo -n "$list_installed" || echo "  (none)"

    echo ""
    echo "CORE (Built-in Standards)"
    echo -n "$list_core"
    echo ""
}

# 11. Command: Run Persona (Updated for V4)
run_persona() {
    local persona=$1
    local project_flag=$2
    local scope=$3
    
    [ -z "$persona" ] && persona="general"
    [ -z "$scope" ] && scope="project"
    local persona_file=$(find_persona_file "$persona")

    if [ ! -f "$persona_file" ]; then
        echo "‚ùå Persona '$persona' not found."
        exit 1
    fi

    # V4: Detect Context
    local project_ctx=$(detect_project_context "$project_flag")
    export GEMONADE_PROJECT="$project_ctx"
    export GEMONADE_SCOPE="$scope"
    export GEMONADE_PERSONA="$persona"
    
    # V4: Init Hook
    run_hook "on_init" "$project_ctx" "$persona"
    
    # Notify user of context
    if [ -f "$STATE_DIR/update_available" ]; then
        echo "‚ÑπÔ∏è  Gemonade Update Available."
    fi
    echo "üíé Gemonade: [$persona] @ [$project_ctx] (Scope: $scope)"

    local package_home=$(dirname "$persona_file")
    # V4.1: strict isolation
    mkdir -p "$G_KNOWLEDGE_DIR/sessions/$persona/$project_ctx"
    mkdir -p "$STATE_DIR"

    # V4.1: Generate Scope Directive
    local scope_md="$STATE_DIR/scope_${persona}_$$.md"
    {
        echo "# ‚ö†Ô∏è Active Access Scope: ${scope^^}"
        case "$scope" in
            persona)
                echo "You have been granted PERSONA-WIDE visibility."
                echo "- You may reference ANY project session logs belonging to the '$persona' persona."
                echo "- Fallback search path: \`knowledge/sessions/$persona/\`"
                echo "- When using \`recall.py\`, do NOT filter by project context unless specifically asked."
                ;;
            global)
                echo "You have been granted GLOBAL visibility (God Mode)."
                echo "- You may reference ANY session logs across ALL personas and projects."
                echo "- Fallback search path: \`knowledge/sessions/\`"
                echo "- When using \`recall.py\`, disable all project filters."
                ;;
            *)
                echo "Standard PROJECT isolation is active."
                echo "- You must only reference session logs within the current project context: '$project_ctx'."
                echo "- Fallback search path: \`knowledge/sessions/$persona/$project_ctx/\`"
                ;;
        esac
    } > "$scope_md"

    if [ ! -d "$package_home/.venv" ] && [ -f "$package_home/requirements.txt" ]; then
        echo "‚ö†Ô∏è  Missing environment. Hydrating..."
        hydrate_gem "$package_home"
    fi

    local active_system_md="$STATE_DIR/system_${persona}_$$.md"
    cat "$G_CORE_PERSONA" "$scope_md" "$persona_file" > "$active_system_md"
    trap "rm -f '$active_system_md' '$scope_md'" EXIT

    # --- Runtime Environment Setup ---
    
    # 0. Core Tools Path (V4: Enable recall.py)
    if [ -d "$GEMONADE_HOME/tools" ]; then
        export PATH="$GEMONADE_HOME/tools:$PATH"
    fi

    # 1. Tools Path
    if [ -d "$package_home/tools" ]; then
        export PATH="$package_home/tools:$PATH"
    fi
    
    if [ -d "$package_home/.venv" ]; then
        export PATH="$package_home/.venv/bin:$PATH"
        export VIRTUAL_ENV="$package_home/.venv"
    fi

    # Launch Gemini CLI
    GEMINI_SYSTEM_MD="$active_system_md" gemini --include-directories "$G_KNOWLEDGE_DIR"

    # Post-session: Run the Saver
    # IMPORTANT: We use the SYSTEM python for the saver because it has no deps,
    # but the INGESTER (in run_hook) uses the Core Venv.
    /usr/bin/env python3 "$G_SAVER_SCRIPT" "$G_KNOWLEDGE_DIR/sessions/$persona/$project_ctx" --project "$project_ctx"
    
    # V4: Exit Hook
    run_hook "on_exit" "$project_ctx" "$persona"
}

# 12. Command Dispatch & Arg Parsing
CMD=""
GEM=""
PROJECT_FLAG=""
SCOPE_FLAG="project"
SUB_CMD=""

while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    --project=*) 
      PROJECT_FLAG="${key#*=}"
      shift
      ;; 
    --scope=*)
      SCOPE_FLAG="${key#*=}"
      shift
      ;;
    --help|-h)
      CMD="help"
      shift
      ;;
    advanced-memory)
      CMD="advanced-memory"
      shift
      if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
          SUB_CMD="$1"
          shift
      fi
      ;; 
    list|install|uninstall|update|search|config|help|run)
      CMD="$1"
      shift
      ;; 
    *) 
      if [ -z "$CMD" ]; then CMD="run"; GEM="$1"; else GEM="$1"; fi
      shift
      ;; 
  esac
done

if [ -z "$CMD" ]; then CMD="run"; GEM="general"; fi

case "$CMD" in
    list) list_personas ;; 
    install) install_gem "$GEM" ;; 
    uninstall) uninstall_gem "$GEM" ;; 
    update) 
        path="$G_INSTALLED_DIR/$GEM"
        if [ -d "$path" ]; then
            echo "‚¨áÔ∏è  Updating $GEM..."
            (cd "$path" && git pull)
            hydrate_gem "$path"
        else
            echo "‚ùå Gem '$GEM' not found in Installed packages."
        fi
        ;; 
    search)
        if [ -f "$GEMONADE_HOME/tools/search.py" ]; then
            python3 "$GEMONADE_HOME/tools/search.py" "$GEM"
        else
            echo "‚ùå Search tool missing."
        fi
        ;; 
    advanced-memory) manage_advanced_memory "$SUB_CMD" ;; 
        config) 
            echo "Gemonade Configuration:"
            echo "  Home:          $GEMONADE_HOME"
            echo "  Packages:      $G_PACKAGE_ROOT"
            echo "  Knowledge:     $G_KNOWLEDGE_DIR"
            echo "  Core Logic:    $G_CORE_PERSONA"
            echo "  Context:       $(detect_project_context "$PROJECT_FLAG")"
            echo "  Scope:         $SCOPE_FLAG"
            ;; 
     
    help|--help|-h) usage ;; 
    run) run_persona "$GEM" "$PROJECT_FLAG" "$SCOPE_FLAG" ;; 
    *) run_persona "$GEM" "$PROJECT_FLAG" "$SCOPE_FLAG" ;; 
esac
